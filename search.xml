<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python-for-Data-Science(4)]]></title>
    <url>%2F2019%2F08%2F03%2FPython-for-Data-Science(4)%2F</url>
    <content type="text"><![CDATA[这个系列终于要写完了…天天写语法知识真的无聊 Working with External Libraries(看这个标题应该是学怎么import module叭 One of the best things about Python (especially if you’re a data scientist) is the vast number of high-quality custom libraries that have been written for it. 123import mathprint("It's math! It has type &#123;&#125;".format(type(math))) 1It&apos;s math! It has type &lt;class &apos;module&apos;&gt; math is just a module. A module is just a collection of variables (a namespace 233333) defined by someone else. Wa can see all the names in math using the built-in function dir(). 1print(dir(math)) 1[&apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan&apos;, &apos;atan2&apos;, &apos;atanh&apos;, &apos;ceil&apos;, &apos;copysign&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;degrees&apos;, &apos;e&apos;, &apos;erf&apos;, &apos;erfc&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;fabs&apos;, &apos;factorial&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;frexp&apos;, &apos;fsum&apos;, &apos;gamma&apos;, &apos;gcd&apos;, &apos;hypot&apos;, &apos;inf&apos;, &apos;isclose&apos;, &apos;isfinite&apos;, &apos;isinf&apos;, &apos;isnan&apos;, &apos;ldexp&apos;, &apos;lgamma&apos;, &apos;log&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log2&apos;, &apos;modf&apos;, &apos;nan&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;radians&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;tan&apos;, &apos;tanh&apos;, &apos;tau&apos;, &apos;trunc&apos;] We can access these variables using dot syntax. Some of them refer to simple values, like math.pi: 1print("pi to 4 significant digits = &#123;:.4&#125;".format(math.pi)) 1pi to 4 significant digits = 3.142 然而真正重要的是 module 里面的各种函数： 1math.log(32, 2) 15.0 We can also call help() on the module itself. This will give us the combined documentation for all the functions and values in the module (as well as a high-level description of the module). Click the “output” button to see the whole math help page. 1help(math) 我们可以在 import 的时候对 module 进行重命名，来方面我们的后期调用： 12import math as mtmt.pi 13.141592653589793 上面的操作也等价于： 12import mathmt = math Wouldn’t it be great if we could refer to all the variables in the math module by themselves? i.e. if we could just refer to pi instead of math.pi or mt.pi? Good news: we can do that. 12from math import *print(pi, log(32, 2)) 13.141592653589793 5.0 123from math import *from numpy import *print(pi, log(32, 2)) 12345678---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-10-5045b296ad83&gt; in &lt;module&gt;() 1 from math import * 2 from numpy import *----&gt; 3 print(pi, log(32, 2))TypeError: return arrays must be of ArrayType 上面这个看起来很诡异的情况是因为 numpy 里面也有一个 log 函数，所以就把前面的函数覆盖了所以比较保险的做法就是把要用的变量导入进去： 12from math import log, pifrom numpy import asarray SubmodulesWe’ve seen that modules contain variables which can refer to functions or values. Something to be aware of is that they can also have variables referring to other modules. 12345import numpyprint("numpy.random is a", type(numpy.random))print("it contains names such as...", dir(numpy.random)[-15:] ) 12numpy.random is a &lt;class &apos;module&apos;&gt;it contains names such as... [&apos;set_state&apos;, &apos;shuffle&apos;, &apos;standard_cauchy&apos;, &apos;standard_exponential&apos;, &apos;standard_gamma&apos;, &apos;standard_normal&apos;, &apos;standard_t&apos;, &apos;test&apos;, &apos;triangular&apos;, &apos;uniform&apos;, &apos;vonmises&apos;, &apos;wald&apos;, &apos;warnings&apos;, &apos;weibull&apos;, &apos;zipf&apos;] So if we import numpy as above, then calling a function in the random “submodule” will require two dots. 123# Roll 10 dicerolls = numpy.random.randint(low=1, high=6, size=10)rolls 1array([3, 4, 4, 2, 5, 3, 5, 1, 2, 3]) Oh the place you’ll go, oh the objects you’ll see上面这句话好像有点酷 So after 6 lessons, you’re a pro with ints, floats, bools, lists, strings, and dicts (right?). Even if that were true, it doesn’t end there. As you work with various libraries for specialized tasks, you’ll find that they define their own types which you’ll have to learn to work with. 所以，我们有如下三大工具来帮助我们对这些额外的 object 进行理解： In the cell above, we saw that calling a numpy function gave us an “array”. We’ve never seen anything like this before (not in this course anyways). But don’t panic: we have three familiar builtin functions to help us here. type() (what is this thing?) 1type(rolls) 1numpy.ndarray dir() (what can I do with it?) 1print(dir(rolls)) 1[&apos;T&apos;, &apos;__abs__&apos;, &apos;__add__&apos;, &apos;__and__&apos;, &apos;__array__&apos;, &apos;__array_finalize__&apos;, &apos;__array_function__&apos;, &apos;__array_interface__&apos;, &apos;__array_prepare__&apos;, &apos;__array_priority__&apos;, &apos;__array_struct__&apos;, &apos;__array_ufunc__&apos;, &apos;__array_wrap__&apos;, &apos;__bool__&apos;, &apos;__class__&apos;, &apos;__complex__&apos;, &apos;__contains__&apos;, &apos;__copy__&apos;, &apos;__deepcopy__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;, &apos;__divmod__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__float__&apos;, &apos;__floordiv__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__iand__&apos;, &apos;__ifloordiv__&apos;, &apos;__ilshift__&apos;, &apos;__imatmul__&apos;, &apos;__imod__&apos;, &apos;__imul__&apos;, &apos;__index__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__int__&apos;, &apos;__invert__&apos;, &apos;__ior__&apos;, &apos;__ipow__&apos;, &apos;__irshift__&apos;, &apos;__isub__&apos;, &apos;__iter__&apos;, &apos;__itruediv__&apos;, &apos;__ixor__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lshift__&apos;, &apos;__lt__&apos;, &apos;__matmul__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__neg__&apos;, &apos;__new__&apos;, &apos;__or__&apos;, &apos;__pos__&apos;, &apos;__pow__&apos;, &apos;__radd__&apos;, &apos;__rand__&apos;, &apos;__rdivmod__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rfloordiv__&apos;, &apos;__rlshift__&apos;, &apos;__rmatmul__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__ror__&apos;, &apos;__rpow__&apos;, &apos;__rrshift__&apos;, &apos;__rshift__&apos;, &apos;__rsub__&apos;, &apos;__rtruediv__&apos;, &apos;__rxor__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__setstate__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__sub__&apos;, &apos;__subclasshook__&apos;, &apos;__truediv__&apos;, &apos;__xor__&apos;, &apos;all&apos;, &apos;any&apos;, &apos;argmax&apos;, &apos;argmin&apos;, &apos;argpartition&apos;, &apos;argsort&apos;, &apos;astype&apos;, &apos;base&apos;, &apos;byteswap&apos;, &apos;choose&apos;, &apos;clip&apos;, &apos;compress&apos;, &apos;conj&apos;, &apos;conjugate&apos;, &apos;copy&apos;, &apos;ctypes&apos;, &apos;cumprod&apos;, &apos;cumsum&apos;, &apos;data&apos;, &apos;diagonal&apos;, &apos;dot&apos;, &apos;dtype&apos;, &apos;dump&apos;, &apos;dumps&apos;, &apos;fill&apos;, &apos;flags&apos;, &apos;flat&apos;, &apos;flatten&apos;, &apos;getfield&apos;, &apos;imag&apos;, &apos;item&apos;, &apos;itemset&apos;, &apos;itemsize&apos;, &apos;max&apos;, &apos;mean&apos;, &apos;min&apos;, &apos;nbytes&apos;, &apos;ndim&apos;, &apos;newbyteorder&apos;, &apos;nonzero&apos;, &apos;partition&apos;, &apos;prod&apos;, &apos;ptp&apos;, &apos;put&apos;, &apos;ravel&apos;, &apos;real&apos;, &apos;repeat&apos;, &apos;reshape&apos;, &apos;resize&apos;, &apos;round&apos;, &apos;searchsorted&apos;, &apos;setfield&apos;, &apos;setflags&apos;, &apos;shape&apos;, &apos;size&apos;, &apos;sort&apos;, &apos;squeeze&apos;, &apos;std&apos;, &apos;strides&apos;, &apos;sum&apos;, &apos;swapaxes&apos;, &apos;take&apos;, &apos;tobytes&apos;, &apos;tofile&apos;, &apos;tolist&apos;, &apos;tostring&apos;, &apos;trace&apos;, &apos;transpose&apos;, &apos;var&apos;, &apos;view&apos;] 123# What am I trying to do with this dice roll data? Maybe I want the average roll, in which case the "mean"# method looks promising...rolls.mean() 13.2 12# Or maybe I just want to get back on familiar ground, in which case I might want to check out "tolist"rolls.tolist() 1[3, 4, 4, 2, 5, 3, 5, 1, 2, 3] help() (tell me more) 12# That "ravel" attribute sounds interesting. I'm a big classical music fan.help(rolls.ravel) 1234567891011121314Help on built-in function ravel:ravel(...) method of numpy.ndarray instance a.ravel([order]) Return a flattened array. Refer to `numpy.ravel` for full documentation. See Also -------- numpy.ravel : equivalent function ndarray.flat : a flat iterator on the array. Operator overloading1[3, 4, 1, 2, 2, 1] + 10 123456---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-20-a2508fc27c2b&gt; in &lt;module&gt;()----&gt; 1 [3, 4, 1, 2, 2, 1] + 10TypeError: can only concatenate list (not &quot;int&quot;) to list but1rolls + 10 1array([13, 14, 14, 12, 15, 13, 15, 11, 12, 13]) When you define a new type, you can choose how addition works for it, or what it means for an object of that type to be equal to something else. The designers of lists decided that adding them to numbers wasn’t allowed. The designers of numpy arrays went a different way (adding the number to each element of the array). Here are a few more examples of how numpy arrays interact unexpectedly with Python operators (or at least differently from lists). 12# At which indices are the dice less than or equal to 3?rolls &lt;= 3 12array([ True, False, False, True, False, True, False, True, True, True]) 1234xlist = [[1, 2, 3], [4, 5, 6],]# Create a 2-dimensional arrayx = numpy.asarray(xlist)print("xlist = &#123;&#125;\nx = \n&#123;&#125;".fotmat(xlist, x)) 1234xlist = [[1, 2, 3], [2, 4, 6]]x =[[1 2 3] [2 4 6]] 12# Get the last element of the second row of our numpy arrayx[1,-1] 16 （当然上面的操作在 xlist 里面是无法被复刻的哦~ numpy’s ndarray type is specialized for working with multi-dimensional data, so it defines its own logic for indexing, allowing us to index by a tuple to specify the index at each dimension. When does 1 + 1 not equal 2?Things can get weirder than this. You may have heard of (or even used) tensorflow, a Python library popularly used for deep learning. It makes extensive use of operator overloading. 12345import tensorflow as tf# Create two constants, each with value 1a = tf.constant(1)b = tf.constant(1)a + b 1&lt;tf.Tensor &apos;add:0&apos; shape=() dtype=int32&gt; a + b isn’t 2, it is (to quote tensorflow’s documentation)… a symbolic handle to one of the outputs of an Operation. It does not hold the values of that operation’s output, but instead provides a means of computing those values in a TensorFlow tf.Session. (说实话这里以及之后的地方我就看不懂了…碍于英语水平？等真正系统学习 tensorflow 的时候我会把这里再补上的) 写在最后：说实话这个Python for Data Science系列写的我十分痛苦，知识点都太无聊而繁琐了，我写文的方式也有问题，后面几乎变成了清一色的 copy kaggle 原文，这个在我以后的博文中一定会改的，将写作方式从边学边记变成学完再整理，给大家带来不好的阅读体验请多海涵（鞠躬]]></content>
      <categories>
        <category>Data Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-for-Data-Science(3)]]></title>
    <url>%2F2019%2F08%2F01%2FPython-for-Data-Science(3)%2F</url>
    <content type="text"><![CDATA[Loops and List ComprehensionsLoops(循环)Loops are a way to repeatedly execute some code.Here’s an example:(没啥好讲的吧？ 注意一下语法格式就行 123planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']for planet in planets: print(planet, end = ' ') # print all on same line 1Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune In addition to lists,we can iterate over the elements of a tuple: 12345multiplicands = (2, 2, 2, 3, 3, 5)product = 1for mult in multiplicands: product = product * multproduct 1360 除了列表与元组，字符串也支持循环：123456s = 'steganograpHy is the practicE of conceaLing a file, message, image, or video within another fiLe, message, image, Or video.'msg = ''# print all the uppercase letters in s, one at a timefor char in s: if char.isupper(): print(char, end='') 1HELLO range() is a function that returns a sequence of numbers. It turns out to be very useful for writing loops.For example, if we want to repeat some action 5 times:12for i in range(5): print("Doing important work. i =", i) 12345Doing important work. i = 0Doing important work. i = 1Doing important work. i = 2Doing important work. i = 3Doing important work. i = 4 除了for循环，还有while循环：1234i = 0while i &lt; 10: print(i, end=' ') i += 1 10 1 2 3 4 5 6 7 8 9 List comprehensions直接看个例子来理解一下list comprehension:12squares = [n**2 for n in range(10)]squares 1[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] We can also add an if condition:12short_planets = [planet for planet in planets if len(planet) &lt; 6]short_planets 1[&apos;Venus&apos;, &apos;Earth&apos;, &apos;Mars&apos;] 好像SQL啊Here’s an example of filtering with an if condition and applying some transformation to the loop variable:123# str.upper() returns an all-caps version of a stringloud_short_planets = [planet.upper() + '!' for planet in planets if len(planet) &lt; 6]loud_short_planets 1[&apos;VENUS!&apos;, &apos;EARTH!&apos;, &apos;MARS!&apos;] 如果你觉得难读，你也可以写成这样：12345[ planet.upper() + '!' for planet in planets if len(planet) &lt; 6] 更像SQL了 Strings and DictionariesStringsOne place where the Python language really shines is in the manipulation of strings. This section will cover some of Python’s built-in string methods and formatting operations.Such string manipulation patterns comde up often in the context of data science work, and is one of big perk of Python in this context. String syntaxString in Python can be defined using either single or double quotations.They are functonally equivalent. 123x = 'Pluto is a planet'y = 'Pluto is a planet'x == y 1True 那为啥还要分单双引号呢？看下面这个例子：12print("Pluto's a planet!")print('My dog is named "Pluto"') 12Pluto&apos;s a planet!My dog is named &quot;Pluto&quot; 当然，我们也可以用反斜杠的方式：1'Pluto\'s a planet!' 1&quot;Pluto&apos;s a planet!&quot; In addition, Python’s tripe quote syntax for strings lets us include newlines literally. We’ve already seen this in the docstrings we use to document our functions, but we can use them anywhere we want to define a string. 123456a = "hello\nworld"b = """helloworld"""print(b)a == b``` helloworldTrue12345678910111213上面可以看到，两种定义方法是等价的。### Strings are sequencesString can be thought of as sequences of characters. **Almost everything we&apos;ve seen that we can do to a list, we can also do to a string.**```pyplanet = &apos;Pluto&apos;planet[0]planet[-3:]len(Planet)[cagr + &apos;!&apos; for char in planet] 1234P&apos;uto&apos;6[&apos;P! &apos;, &apos;l! &apos;, &apos;u! &apos;, &apos;t! &apos;, &apos;o! &apos;] But a majoy way in which they differ from lists is that they are immutable. We can’t modify them. 12# 这种操作就会报错！！！planet[0] = 'B' (这好像跟元组差不多？ String methods ALL CPS 123claim = "Pluto is a planet!"claim.upper()# 不改变 calim 本身 1&apos;PLUTO IS A PLANET!&apos; all lowercase 1claim.lower() 1&apos;pluto is a planet!&apos; search for the first index of a string 1claim.index('plan') 1111 startswith() and endswith() 1claim.startswith(planet) 1True 1claim.endswith('dwarf planet') 1False split() and join() 12words = claim.split()words 1[&apos;Pluto&apos;, &apos;is&apos;, &apos;a&apos;, &apos;planet!&apos;] 默认空格，也可以自己传参 12345datestr = '1956-01-31'a = datestr.split('-')print(a)year, month, day = datestr.split('-')print(year, month, day) 12[&apos;1956&apos;, &apos;01&apos;, &apos;31&apos;]1956 01 31 jion() 函数刚好相反哦~ 1'/'.join([month, day, year]) 1&apos;01/31/1956&apos; Building strings with format() 直接用 + 就可以将两个字符串相连 1planet + ', we miss you.' 1&apos;Pluto, we miss you.&apos; If we want to throw in any non-string objects, we have to be careful to call str() on them first 12position = 9planet + ", you'll always be the " + str(position) + "th planet to me." 1&quot;Pluto, you&apos;ll always be the 9th planet to me.&quot; 这个 code 看起来就不舒服，所以，还有下面这种方法： 1"&#123;&#125;, you'll always be the &#123;&#125;th planet to me.".format(planet, position) 1&quot;Pluto, you&apos;ll always be the 9th planet to me.&quot; 是不是看懂了？还可以在大括号内自定义格式喔~ 1234567pluto_mass = 1.303 * 10**22earth_mass = 5.9722 * 10**24population = 52910390# 2 decimal points 3 decimal points, format as percent separate with commas"&#123;&#125; weighs about &#123;:.2&#125; kilograms (&#123;:.3%&#125; of Earth's mass). It is home to &#123;:,&#125; Plutonians.".format( planet, pluto_mass, pluto_mass / earth_mass, population,) 1&quot;Pluto weighs about 1.3e+22 kilograms (0.218% of Earth&apos;s mass). It is home to 52,910,390 Plutonians.&quot; 可以根据下标指定字符串123456# Referring to format() arguments by index, starting from 0s = """Pluto's a &#123;0&#125;.No, it's a &#123;1&#125;.&#123;0&#125;!&#123;1&#125;!""".format('planet', 'dwarf planet')print(s) 1234Pluto&apos;s a planet.No, it&apos;s a dwarf planet.planet!dwarf planet! DictionariesDictionaries are a built-in Python data structure for mapping keys to values. 123# 基本定义方法numbers = &#123;'one':1, 'two':2, 'three':3&#125;numvers['one'] 11 我们也可以直接添加元素： 12nukber['eleven'] = 11numbers 1&#123;&apos;one&apos;: 1, &apos;two&apos;: 2, &apos;three&apos;: 3, &apos;eleven&apos;: 11&#125; 修改也是这种操作：12numbers['one'] = 'Pluto'numbers 1&#123;&apos;one&apos;: &apos;Pluto&apos;, &apos;two&apos;: 2, &apos;three&apos;: 3, &apos;eleven&apos;: 11&#125; Python has dictionary comprehensions with a syntax similar to the list comprehensions we saw in the previous tutorial. 123planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']planet_to_initial = &#123;planet: planet[0] for planet in planets&#125;planet_to_initial 12345678&#123;&apos;Mercury&apos;: &apos;M&apos;, &apos;Venus&apos;: &apos;V&apos;, &apos;Earth&apos;: &apos;E&apos;, &apos;Mars&apos;: &apos;M&apos;, &apos;Jupiter&apos;: &apos;J&apos;, &apos;Saturn&apos;: &apos;S&apos;, &apos;Uranus&apos;: &apos;U&apos;, &apos;Neptune&apos;: &apos;N&apos;&#125; 12# 用 in 的条件判断'Saturn' in planet_to_initial 1True 这个映射是前面映射后面哈，&#39;E&#39; in planets这样就是False了。 12for k in numbers: print("&#123;&#125; = &#123;&#125;".format(k, numbers[k])) 1234one = Plutotwo = 2three = 3eleven = 11 12# Get all the initials, sort them alphabetically, and put them in a space-separated string.' '.join(sorted(planet_to_initial.values())) 1&apos;E J M M N S U V&apos; The very useful dict.items() method lets us iterate over the keys and values of a dictionary simultaneously. (In Python jargon, an item refers to a key, value pair) 1planet_to_initial.items() 1dict_items([(&apos;Mercury&apos;, &apos;M&apos;), (&apos;Venus&apos;, &apos;V&apos;), (&apos;Earth&apos;, &apos;E&apos;), (&apos;Mars&apos;, &apos;M&apos;), (&apos;Jupiter&apos;, &apos;J&apos;), (&apos;Saturn&apos;, &apos;S&apos;), (&apos;Uranus&apos;, &apos;U&apos;), (&apos;Neptune&apos;, &apos;N&apos;)]) 12for planet, initial in planet_to_initial.items(): print("&#123;&#125; begins with \"&#123;&#125;\"".format(planet.rjust(10), initial)) 12345678Mercury begins with &quot;M&quot; Venus begins with &quot;V&quot; Earth begins with &quot;E&quot; Mars begins with &quot;M&quot;Jupiter begins with &quot;J&quot; Saturn begins with &quot;S&quot; Uranus begins with &quot;U&quot;Neptune begins with &quot;N&quot; tips: ljust() and rjust() 是右对齐和左对齐]]></content>
      <categories>
        <category>data science</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["8数码问题及其泛化"]]></title>
    <url>%2F2019%2F07%2F31%2F15%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E6%B3%9B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[(本博客思路部分基本为转载) 先来看下题目： Problem DescriptionYou are given a 4 × 4 grid, which consists of 15 number cells and an empty cell.All numbers are unique and ranged from 1 to 15.In this board, the cells which are adjacent with the empty cell can move to the empty cell.Your task is to make the input grid to the target grid shown in the figure below.In the following example (sample input), you can get the target grid in two moves. Inputhe first line contains an integer T (1 &lt;= T &lt;= 10^5) denoting the number of test cases.Each test case consists of four lines each containing four space-separated integers, denoting the input grid. 0 indicates the empty cell. OutputFor each test case, you have to print the answer in one line.If you can’t get the target grid within 120 moves, then print ‘No’, else print ‘Yes’. Sample Input 21 2 3 45 6 7 89 10 0 1213 14 11 151 2 3 45 6 7 89 10 11 1213 15 14 0 Sample Output YesNo 题目思路先来学一下8数码问题的解法：首先把所有数字（不包括空位的0）写成一行，就得到了一个1~8的排列，考虑空位的交换情况：1.左右交换，2.上下交换。对于左右交换而言，是不会改变写出的排列的逆序数的；而对上下交换，相当于在排列中向前或向后跳了两个位置，那么要么两个数都比它大或小，这样逆序数加2或减2，要么两个数一个比它大一个比它小，这样逆序数不变，综上，对于八数码问题，操作不会改变逆序数的奇偶性，所以只有初始状态和指定状态的逆序数奇偶性相同就有解。 弄清楚了八数码，扩展起来就容易了，现在我们将其扩展到N维（即N N的board，N N - 1数码问题）。 首先无论N的奇偶，左右交换不改变逆序数，N为奇数时：上下交换逆序数增加N-1或减少N-1或不变，因为N为奇数，所以逆序数奇偶性不变；而N为偶数时：上下交换一次奇偶性改变一次。 结论：N为奇数时，初始状态与指定状态逆序数奇偶性相同即有解；N为偶数时，先计算出从初始状态到指定状态，空位要移动的行数m，如果初始状态的逆序数加上m与指定状态的逆序数奇偶性相同，则有解。 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define numm ch-48#define pd putchar(' ')#define pn putchar('\n')#define pb push_back#define fi first#define se second#define mid (l + r) / 2#define fre1 freopen("1.txt","r",stdin)#define fre2 freopen("2.txt","w",stdout)typedef long long int ll;typedef long long int LL;using namespace std;template &lt;typename T&gt;void read(T&amp; res) &#123; bool flag = false; char ch; while (!isdigit(ch = getchar())) (ch == '-') &amp;&amp; (flag = true); for (res = numm; isdigit(ch = getchar()); res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + numm); flag &amp;&amp; (res = -res);&#125;template &lt;typename T&gt;void write(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;//////////////////////////////////////////////////////////////////////////////////////////////int a[16];int b[15];int main() &#123; int T; read(T); while (T--) &#123; memset(a, 0, sizeof(a)); int m, cnt = 0, t = 0; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; read(a[i * 4 + j]); if (a[i * 4 + j] == 0) &#123; m = 3 - i; &#125; else &#123; b[t++] = a[i * 4 + j]; &#125; &#125; &#125; for (int i = 0; i &lt; 15; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (b[i] &lt; b[j]) &#123; cnt++; &#125; &#125; &#125; if (!((cnt + m) % 2)) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["Python for Data Science(2)"]]></title>
    <url>%2F2019%2F07%2F28%2FPython-for-Data-Science(2)%2F</url>
    <content type="text"><![CDATA[Booleans and conditionalsBooleansPython里面也有bool类型的变量True 和 False 记得首字母大写 所有 Comparison Operations 的返回值都是bool类型的 Python还提供三个运算符：and or not 分别对应 与 或 非 三种操作直白到令人不适 ConditionalsPython中的条件运算符长这样： 123456789def inspect(x): if x == 0: print(x, "is zero") elif x &gt; 0: print(x, "is positive") elif x &lt; 0: print(x, "is negative") else: print(x, "is unlike anything I've ever seen...") 哦对，Python中好像没有大括号这种操作，命令域全靠缩进 ListsIntroduceLists in Python represent ordered sequences of values.跟C++中的数组相类似 下面是创建方法：123456789101112131415primes = [2, 3, 5, 7]planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']hands = [ ['J', 'Q', 'K'], ['2', '2', '2'], ['6', 'A', 'K'], # (Comma after the last element is optional)]# (I could also have written this on one line, but it can get hard to read)hands = [['J', 'Q', 'K'], ['2', '2', '2'], ['6', 'A', 'K']]# 下面这个操作比较骚# A list can contain a mix of different types of variables:my_favourite_things = [32, 'raindrops on roses', help] 可以通过 index 来访问 list 中的元素： 1234567891011121314planets[0]planets[1]# 下面这俩比较骚：planets[-1]planets[-2]# 群引用遵循左闭右开原则，可以省略初始和结尾planets[0:3]planets[:3]planets[3:]planets[1:-1]planets[-3:] 他们的值分别是： 123456789101112&apos;Mercury&apos;&apos;Venus&apos;&apos;Neptune&apos;&apos;Uranus&apos;[&apos;Mercury&apos;, &apos;Venus&apos;, &apos;Earth&apos;][&apos;Mercury&apos;, &apos;Venus&apos;, &apos;Earth&apos;][&apos;Mars&apos;, &apos;Jupiter&apos;, &apos;Saturn&apos;, &apos;Uranus&apos;, &apos;Neptune&apos;][&apos;Venus&apos;, &apos;Earth&apos;, &apos;Mars&apos;, &apos;Jupiter&apos;, &apos;Saturn&apos;, &apos;Uranus&apos;][&apos;Saturn&apos;, &apos;Uranus&apos;, &apos;Neptune&apos;] 想要修改通过类似下面的操作就可以了：12planets[3] = 'Malacandra'planets[:3] = ['Mur', 'Vee', 'Ur'] List functionslen gives the lengths if a list：1len(planets) 18 sorted returns a sorted version of a list:1sorted(planets) 12# The planets sorted in alphabetical order(字典序)[&apos;Earth&apos;, &apos;Jupiter&apos;, &apos;Mars&apos;, &apos;Mercury&apos;, &apos;Neptune&apos;, &apos;Saturn&apos;, &apos;Uranus&apos;, &apos;Venus&apos;] 注：sorted并不改变原list的顺序 max, min and sum1234primes = [2, 3, 5, 7]max(primes)min(primes)sum(primes) 1231772 objects突然插点题外话，对于 Python 来说，万物皆对象就比如说，数字4就是一个对象，它具有对象的性质，即具有arrtibute和method 1234567x = 12print(x.imag)c = 12 + 3jprint(c.imag)x.bit_length() 12303.04 我们来观察一下上述三个输出，imag是输出一个数的虚数部分，而c = 12 = 3j则是定义一个虚数的正确方式，x.bit_length()则是输出这个数字的二进制长度，12的二进制是1100，有四位。 tips help()对arrtibute和method依然生效，可以使用类似help(x.bit_length())的方式调用， 我为什么突然介绍起 object 呢？ 因为接下来将介绍 list 作为 object 的表现。 List methodslist.append modifies a list by adding an item to the end: 12# Pluto is a planet darn it!planets.append('Pluto') list.pop remove and returns the last element of a list: 似曾相识的操作 1planets.pop() 1&apos;Plutos&apos; list.index返回元素的下标1planets.index('Earth') 12 接下来再看神奇的成员运算符inandnot in 12'Earth' in planets'Earth' not in planets 12TrueFalse 最后，用help(planets)就能获得所有你还想知道的知识啦！赶快去试试吧~ Tuples(元组)Tuples are almost exactly the same as lists.They differ in just two ways. The Syntax for creating them uses parentheses instead of square brackets. They cannot be modified(they are immutable). 12t = (1, 2, 3)t[0] = 100 1234567---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-6-ca3b752cda23&gt; in &lt;module&gt; 1 t = (1, 2, 3)----&gt; 2 t[0] = 100TypeError: &apos;tuple&apos; object does not support item assignment Tuples are often used for functions that have multiple return values. For example, the as_integer_ratio() method of float objects returns a numerator and a denominator in the form of a tuple: 12x = 0.125x.as_integer_ratio() 10.125]]></content>
      <categories>
        <category>data science</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["主席树(再探线段树)"]]></title>
    <url>%2F2019%2F07%2F26%2F%E4%B8%BB%E5%B8%AD%E6%A0%91-%E5%86%8D%E6%8E%A2%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[好了我终于又想起来我是一名辣鸡ACMer了，今天来继续更新数据结构。 主席树(presistent segment tree)，又名可持久化线段树、动态开点线段树、权值线段树、可持久化柠檬树 要想搞明白这是个啥，我给你提供oi-wiki链接，反正我是觉得我说不明白这么复杂的玩意。 先惯例上版子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define numm ch-48#define pd putchar(' ')#define pn putchar('\n')#define pb push_back#define fi first#define se second#define mid (l + r) &gt;&gt; 1#define fre1 freopen("1.txt","r",stdin)#define fre2 freopen("2.txt","w",stdout)typedef long long int ll;using namespace std;template &lt;typename T&gt;void read(T&amp; res) &#123; bool flag = false; char ch; while (!isdigit(ch = getchar())) (ch == '-') &amp;&amp; (flag = true); for (res = numm; isdigit(ch = getchar()); res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + numm); flag &amp;&amp; (res = -res);&#125;template &lt;typename T&gt;void write(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;//////////////////////////////////////////////////////////////////////////////////////////////////const int N = 200010;int n, q, m, cnt = 0;int a[N], b[N], T[N];int sum[N &lt;&lt; 5], L[N &lt;&lt; 5], R[N &lt;&lt; 5];inline int getid(const int &amp;val) //离散化&#123; return lower_bound(b + 1, b + m + 1, val) - b;&#125;int build(int l, int r) &#123; int rt = ++cnt; sum[rt] = 0; if (l &lt; r) &#123; L[rt] = build(1, mid); R[rt] = build(mid + 1, r); &#125; return rt;&#125;int update(int pre, int l, int r,int x) &#123; int rt = ++cnt; L[rt] = L[pre]; R[rt] = R[pre]; sum[rt] = sum[pre] + 1; if (l &lt; r) &#123; if (x &lt;= mid) L[rt] = update(L[pre], 1, mid, x); else R[rt] = update(R[pre], mid + 1, r, x); &#125; return rt;&#125;int query(int u, int v, int l, int r, int k) &#123; if (l &gt;= r) return l; int x = sum[L[v]] - sum[L[u]]; if (x &gt;= k) return query(L[u], L[v], 1, mid, k); else return query(R[u], R[v], mid + 1, r, k - x);&#125;int main() &#123; read(n); read(q); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); b[i] = a[i]; &#125; sort(b + 1, b + 1 + n); m = unique(b + 1, b + 1 + n) - b - 1; T[0] = build(1, m); for (int i = 1; i &lt;= n; i++) &#123; int t = getid(a[i]); T[i] = update(T[i - 1], 1, m, t); &#125; while (q--) &#123; int x, y, z; read(x); read(y); read(z); int t = query(T[x - 1], T[y], 1, m, z); while (b[t]); pn; &#125; return 0;&#125; 上述板子是洛谷版子题的题解。 由于主席树比较复杂，我在这里简单解释一下思路，（这样我以后来粘的时候还方便一点23333） a[]和b[]是来保存最初的数组的，传入值后对b[]进行排序去重(离散化)。 一个很重要的概念，L，R，T 三个数组保存的内容全都是下标： L[]和R[]用来存储左右子树的下标，比如L[x]即为标号为x的结点的左子树标号为L[x] 由于主席树实际上是根据插入 n 个点形成 n 个权值线段树，所以用数组T[]来保存每次新线段树的根节点下标 build()函数递归建树，变量rt表示当前下标(注：因为采取动态开点的方式，实际上每开一个点就是在已开的数组末尾再开一个，实际存储结构与逻辑结构没关系，并不是堆存储那种) getid()用来获取某个值在b[]中的下标位置，即离散化后的顺序 sum[]数组用来存放前缀元素的个数，即sum[x]表示从]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["Python for Data Science(1)"]]></title>
    <url>%2F2019%2F07%2F25%2FPython-for-Data-Science(1)%2F</url>
    <content type="text"><![CDATA[好的我又来挖坑了嘿嘿 喂喂你说好的更新数据结构呢？主席树啥时候能出来啊 本文是基于 Kaggle 上的 Python 在数据科学里面的应用入门课的学习笔记性质的博文，实际写作过程也是一边学一边写的，所以有所偏颇或遗漏的地方欢迎评论指正喂喂你给你的blog载入评论模块了嘛由于我是具有一定编程基础的，所以并不会过多的介绍 code 逻辑思想，本文可能更适合已经掌握至少一门编程语言的读者。 1. Numbers and arithmetic in Python基础操作符 Operator Name Description a + b Addition Sum of a and b a - b Subtraction Difference of a and b a * b Multiplication Product of a and b a / b True division Quotient of a and b a // b Floor division Quotient of a and b, removing fractional parts a % b Modulus Integer remainder after division of a by b a ** b Exponentiation a raised to the power of b -a Negation The negative of a 基本都跟 c++ 类似哈，唯一不同的就是这个 / 和 // ，其中 // 是 floor vivision(即与 c++ 中的 / 一致，抹去小数位)，而 / 是 ture division(保留小数位)。 Tips:abs(num)是求 num 的绝对值，对 int 和 float 生效 int(&#39;807&#39;)是转换数据类型(必须严格遵守格式，如果int(‘1.2’)则会报错) 简单介绍一下Python中的数据类型： Python3 中有六个标准的数据类型： Number（数字）String（字符串）List（列表）Tuple（元组）Set（集合）Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 2. Functions and Getting Helpdef创建函数先来演示一下Python怎么创建函数； 1234567891011# 无参无返回值def print_kesisour(): print("kesisour")# 无参有返回值def return_kesisour(): return "kesisour"# 有参无返回值def print_name(name): print(name) 上面利用def关键字创建了三个最基本的函数，函数在无返回的时候返回值为None(This is similar to the concept of “null” in other languages.) Getting HelpPython里面内置了一个非常人性化的函数help，用它可以查看函数的函数头，撰写了docstring的函数还可以显示docstring，赶紧来实战一下： 12# 我 问 我 自 己help(help) output(以后默认code后面的即为输出，不再标志):123456789101112131415161718192021222324252627Help on _Helper in module _sitebuiltins object:class _Helper(builtins.object) | Define the builtin &apos;help&apos;. | | This is a wrapper around pydoc.help that provides a helpful message | when &apos;help&apos; is typed at the Python interactive prompt. | | Calling help() at the Python prompt starts an interactive help session. | Calling help(thing) prints help for the python object &apos;thing&apos;. | | Methods defined here: | | __call__(self, *args, **kwds) | Call self as a function. | | __repr__(self) | Return repr(self). | | ---------------------------------------------------------------------- | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) 好了我用上面这个例子除了演示一下help的用法之外，也是为了证明一件事，help本身也是一个函数。有关help的用法在这里也不再演示了，读者可以在日常使用过程中自行尝试。 Default arguments首先我们来help(print)看一下：1234567891011Help on built-in function print in module builtins:print(...) print(value, ..., sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. 发现了吗？print除了传入的变量之外，还有四个内置的参数，如果不设置他们的值，他们的值就是默认的，这种就称为 default arguments(默认参数) 来看一下用法： 12print(1, 2, 3)print(1, 2, 3, sep = "&lt;") 121 2 31&lt;2&lt;3 sep默认为空格，但如果自行定义的话，则会覆盖掉原本的空格。 如何在自己设置的函数中创建default arguments： 1234567def greet(who="Colin"): print("Hello,", who) greet()greet(who="Kaggle")# (In this case, we don't need to specify the name of the argument, because it's unambiguous.)greet("world") 123Hello, ColinHello, KaggleHello, world Functions Applied to FunctionsHigher order functions 使用演示： 12345678910111213141516def mult_by_five(x): return 5 * xdef call(fn, arg): &quot;&quot;&quot;Call fn on arg&quot;&quot;&quot; return fn(arg)def squared_call(fn, arg): &quot;&quot;&quot;Call fn on the result of calling fn on arg&quot;&quot;&quot; return fn(fn(arg))print( call(mult_by_five, 1), squared_call(mult_by_five, 1), sep=&apos;\n&apos;, # &apos;\n&apos; is the newline character - it starts a new line) 12525 这对于有编程基础的读者来说非常简单吧，只需要记一下写法即可，接下来来演示一个有意思的东西：先来看一下help(max)12345678910Help on built-in function max in module builtins:max(...) max(iterable, *[, default=obj, key=func]) -&gt; value max(arg1, arg2, *args, *[, key=func]) -&gt; value With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if the provided iterable is empty. With two or more arguments, return the largest argument. 有一个key关键字，可以自己定义：1234567891011def mod_5(x): """Return the remainder of x after dividing by 5""" return x % 5print( 'Which number is biggest?', max(100, 51, 14), 'Which number is the biggest modulo 5?', max(100, 51, 14, key=mod_5), sep='\n',) 1234Which number is biggest?100Which number is the biggest modulo 5?14]]></content>
      <categories>
        <category>data science</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["线段树初探"]]></title>
    <url>%2F2019%2F07%2F21%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[好了，我在昨天的练习赛中备受打击孔乙己你是不是又爆零了，果然还是要一步一个脚印，从基础的数据结构一点一点补起。 说起来，这并不是我第一次写线段树了，然鹅这个东西他不过脑啊2333333还是要把东西整理下来，总结一个个板子这样下次再想用的时候直接复制就好啦也能迅速上手。 线段树简介&amp;实现线段树(Segment Tree)的具体定义自己百度去 来简单介绍下segment tree的实现方式，首先开个数组a[n]来进行数据的存储，然后用一个4n大小的数组st[4n]来进行segment tree的存储(为啥开4n网上有很多现成的证明，自己去搜)，线段树的具体建立方式是st[p] = st[2 * p] + st[2 * p + 1],用一个函数递归建立即可，如下：123456789void build(int s, int t, int p) &#123; //建树 if (s == t) &#123; st[p] = a[s]; return; &#125; int m = (s + t) &gt;&gt; 1; build(s, m, LS(p)), build(m + 1, t, RS(p)); st[p] = st[LS(p)] + st[RS(p)];&#125; 是不是非常简单呢?你是不是忘了自己被线段树折磨成啥样子了 然后建立lazy数组lazy[4n]进行lazy操作，具体解释参见oi-wiki，然后再写写update，getsum，一个最简易的线段树就出来了呢~~~史上最简洁线段树介绍Over 以我写博客的懒散风格，直接上我撸的板子这真是怠惰呢 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define numm ch-48#define pd putchar(' ')#define pn putchar('\n')#define pb push_back#define fi first#define se second#define fre1 freopen("1.txt","r",stdin)#define fre2 freopen("2.txt","w",stdout)typedef long long int ll;using namespace std;template &lt;typename T&gt;void read(T&amp; res) &#123; bool flag = false; char ch; while (!isdigit(ch = getchar())) (ch == '-') &amp;&amp; (flag = true); for (res = numm; isdigit(ch = getchar()); res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + numm); flag &amp;&amp; (res = -res);&#125;template &lt;typename T&gt;void write(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;//////////////////////////////////////////////////////////////////////////////////////////////////#define LS(a) (a &lt;&lt; 1)#define RS(a) (a &lt;&lt; 1 | 1)const int maxn = 1e6;ll a[maxn], st[4 * maxn];ll lazy[4 * maxn] = &#123; 0 &#125;;void build(int s, int t, int p) &#123; //建树 if (s == t) &#123; st[p] = a[s]; return; &#125; int m = (s + t) &gt;&gt; 1; build(s, m, LS(p)), build(m + 1, t, RS(p)); st[p] = st[LS(p)] + st[RS(p)];&#125;void down(int l, int r, int s, int t, int p) &#123; //下放函数 int m = (s + t) &gt;&gt; 1; st[LS(p)] += lazy[p] * (m - s + 1); st[RS(p)] += lazy[p] * (t - m); lazy[LS(p)] += lazy[p]; lazy[RS(p)] += lazy[p]; lazy[p] = 0;&#125;void update(int l, int r, int c, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; r &gt;= t) &#123; st[p] += (t - s + 1) * c; lazy[p] += c; return; &#125; if (lazy[p]) down(l, r, s, t, p); int m = (s + t) &gt;&gt; 1; if (l &lt;= m) update(l, r, c, s, m, LS(p)); if(r &gt; m) update(l, r, c, m + 1, t, RS(p)); st[p] = st[LS(p)] + st[RS(p)];&#125;ll getsum(int l, int r, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; r &gt;= t) return st[p]; if(lazy[p]) down(l, r, s, t, p); int m = (s + t) &gt;&gt; 1; ll sum = 0; if (l &lt;= m) sum = getsum(l, r, s, m, LS(p)); if (r &gt; m) sum += getsum(l, r, m + 1, t, RS(p)); return sum;&#125;int main() &#123; int n, m; read(n); read(m); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); &#125; build(1, n, 1); int flag;for (int i = 1; i &lt;= m; i++) &#123; read(flag); if (flag == 1) &#123; int x, y, k; read(x); read(y); read(k); update(x, y, k, 1, n, 1); &#125; else &#123; int x, y; read(x); read(y); write(getsum(x, y, 1, n, 1)); pn; &#125; &#125; return 0;&#125; 以上的板子是洛谷上一道板子题的题解：P3372 【模板】线段树 1 然后是我摘的一个有multiply操作的线段树，代码如下：注意，乘法的lazy操作需要另外建立一个lazy数组，且乘法lazy数组的初始状态均为1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define sea 100010#define LL long long #define left l,mid,k&lt;&lt;1#define right mid+1,r,k&lt;&lt;1|1#define lef k&lt;&lt;1 #define rig k&lt;&lt;1|1using namespace std;int n,m,p,s,x,y;long long sum[sea*4],kk,lazy_ad[sea*4],lazy_mu[sea*4];inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1; ch=getchar();&#125; while(ch&lt;='9'&amp;&amp;ch&gt;='0') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;inline LL read_ll()//傻掉的我自己，为什么不用scanf~~~(算了不改了)&#123; LL s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1; ch=getchar();&#125; while(ch&lt;='9'&amp;&amp;ch&gt;='0') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;void build(int l,int r,int k)//建树&#123; lazy_mu[k]=1;//乘最初为一 if(l==r) sum[k]=read_ll(); else &#123; int mid=(l+r)&gt;&gt;1; build(left); build(right); sum[k]=(sum[lef]+sum[rig])%p;// &#125; return ;&#125;void push(int l,int r,int k,LL a,LL b)//标记&#123; lazy_ad[k]=(lazy_ad[k]*b+a)%p; lazy_mu[k]=(lazy_mu[k]*b)%p; sum[k]=(sum[k]*b+(r-l+1)*a)%p;&#125;void down(int l,int r,int k)//下放&#123; int mid=(l+r)&gt;&gt;1; push(left,lazy_ad[k],lazy_mu[k]); push(right,lazy_ad[k],lazy_mu[k]); lazy_ad[k]=0; lazy_mu[k]=1; return ;&#125;void midefy(int l,int r,int k,LL a,LL b)//加乘一块用了&#123; if(x&lt;=l&amp;&amp;r&lt;=y) push(l,r,k,a,b); elsstation &#123; if(lazy_ad[k]!=0||lazy_mu[k]!=1) down(l,r,k); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) midefy(left,a,b); if(y&gt;mid) midefy(right,a,b); sum[k]=(sum[lef]+sum[rig])%p; &#125; return ;&#125;LL ask(int l,int r,int k)//询问&#123; if(x&lt;=l&amp;&amp;r&lt;=y) return sum[k]; if(lazy_ad[k]!=0||lazy_mu[k]!=1) down(l,r,k); int mid=(l+r)&gt;&gt;1; LL ans=0; if(x&lt;=mid) ans=(ans+ask(left))%p; if(y&gt;mid) ans=(ans+ask(right))%p; return ans;&#125;int main()&#123; n=read(); m=read(); p=read(); build(1,n,1); while(m--) &#123; s=read(); if(s==1)//区间加 &#123; x=read(); y=read(); kk=read_ll(); midefy(1,n,1,0,kk); &#125; else if(s==2)//区间乘 &#123; x=read(); y=read(); kk=read_ll(); midefy(1,n,1,kk,1); &#125; else//询问 &#123; x=read(); y=read(); printf("%lld\n",ask(1,n,1)); &#125; &#125; return 0;&#125; 上面的code对应另一道板子题P3373 【模板】线段树 2 好啦~最近可能会多更一些数据结构的题，先把数据结构都补完，才能在竞赛中有一点点立足之本，小宸绝对不自闭。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构,线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["笛卡尔树及比较方法"]]></title>
    <url>%2F2019%2F07%2F18%2F%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%E5%8F%8A%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[（片头注：本文实为边学边写的学习笔记，可能存在逻辑不连贯或突然顿悟等现象，想获得更好的学习体验的朋友可以移步更为成熟的博文） 笛卡尔树定义笛卡尔树是一个很有意思的树形结构，因为它同时满足两个性质，从key（key就是索引位置，如下图中9的key为1，3的key为2……）来看，满足二叉搜索树的特性，从value来看，满足堆的性质。 笛卡尔树的构造 从第一个元素开始，从左往右遍历数组L 将元素L[0]作为树的根节点R for i in [a[1], a[2]…a[n]] 如果a[i]小于根节点R，则将a[i]作为根节点R的父节点 如果a[i]大于根节点R，则将a[i]从根节点的右节点开始寻找位置 从右寻找的逻辑同根节点的对比方法 下面是具体的构造code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;typedef struct node_s&#123; struct node_s* l; struct node_s* r; struct node_s* p; int v;&#125;node_t;typedef struct tree_s&#123; node_t* root;&#125;tree_t;node_t* node_create(node_t* p, int v)&#123; node_t* n = (node_t*)malloc(sizeof(node_t)); memset(n, 0, sizeof(node_t)); n-&gt;v = v; n-&gt;p = p; return n;&#125;tree_t* tree_create()&#123; tree_t* t = (tree_t*)malloc(sizeof(tree_t)); memset(t, 0, sizeof(tree_t)); return t;&#125;void tree_insert_n(node_t* root, int v)&#123; //当前节点比根节点小，则转换为根节点 if (v &lt; root-&gt;v) &#123; node_t* n = node_create(root-&gt;p, v); root-&gt;p-&gt;r = n; root-&gt;p = n; n-&gt;l = root; &#125; else &#123; //如果右子树不存在，直接放置 if (root-&gt;r == 0) &#123; root-&gt;r = node_create(root, v); return; &#125; //当前的节点比根节点大，则从根节点的右子树开始查找 tree_insert_n(root-&gt;r, v); &#125;&#125;void tree_insert(tree_t* t, int v)&#123; if (t-&gt;root == 0) &#123; t-&gt;root = node_create(0, v); return; &#125; //当前节点比根节点小，则转换为根节点 if (v &lt; t-&gt;root-&gt;v) &#123; node_t* n = node_create(0, v); t-&gt;root-&gt;p = n; n-&gt;l = t-&gt;root; t-&gt;root = n; &#125; else &#123; //如果右子树不存在，直接放置 if (t-&gt;root-&gt;r == 0) &#123; t-&gt;root-&gt;r = node_create(t-&gt;root, v); return; &#125; //当前的节点比根节点大，则从根节点的右子树开始查找 tree_insert_n(t-&gt;root-&gt;r, v); &#125;&#125;void tree_print_n(node_t* n, int level, char dir)&#123; if (!n) &#123; return; &#125; for (int i = 0; i &lt; level; ++i) &#123; printf("---"); &#125; printf("%c--%d\n", dir, n-&gt;v); tree_print_n(n-&gt;l, level + 1, 'L'); tree_print_n(n-&gt;r, level + 1, 'R');&#125;void tree_print(tree_t* tree)&#123; tree_print_n(tree-&gt;root, 0, 'C'); printf("\n");&#125;void tree_free(tree_t* t)&#123;&#125;int main()&#123; int n, height; while (scanf("%d", &amp;n), n) &#123; int arr[n]; tree_t* tree = tree_create(); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; for (int i = 0; i &lt; n; ++i) &#123; tree_insert(tree, arr[i]); tree_print(tree); &#125; tree_free(tree); printf("\n"); &#125; return 0;&#125; (当然这个不是重点~需要用的时候自取就好啦~)(我连看都没看直接从别的地方粘贴过来了) 笛卡尔树的应用好了接下来切入正题，为什么我今天就跟笛卡尔树过不去了，原因在于下面这道题(来源：2019牛客暑期多校训练营（第一场）A题)： 这题害我今天下午的训练只做了一道签到题这真是道好题啊 Sample Input&amp;&amp;Output Sample Input21 22 132 1 33 1 253 1 5 2 45 2 4 3 1 Sample Output:134 从赛后题解看到，这题中两个数组equivalent等价于两个数组构成的笛卡尔树形状相同，所以剩下的事就简单了，比较两个数组的笛卡尔树是否相同即可真的简单吗？？？喂！下面粘一位大佬的题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define numm ch-48#define pd putchar(' ')#define pn putchar('\n')#define pb push_back#define fi first#define se second#define fre1 freopen("1.txt","r",stdin)#define fre2 freopen("2.txt","w",stdout)using namespace std;template &lt;typename T&gt;void read(T&amp; res) &#123; bool flag = false; char ch; while (!isdigit(ch = getchar())) (ch == '-') &amp;&amp; (flag = true); for (res = numm; isdigit(ch = getchar()); res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + numm); flag &amp;&amp; (res = -res);&#125;template &lt;typename T&gt;void write(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;const int maxm = 8000010;const int maxn = 1e5 + 7;const int inf = 0x3f3f3f3f;const int INF = 0x7fffffff;typedef long long ll;int a[maxn], b[maxn];int MinPosA[maxn], MinA;int MinPosB[maxn], MinB;int q1[maxn], q2[maxn];int main()&#123; int n; while (scanf("%d", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= n; i++) read(b[i]); int head1 = 1, tail1 = 1; int head2 = 1, tail2 = 1; q1[head1] = q2[head1] = inf; int pos = 1; for (int i = 1; i &lt;= n; i++) &#123; while (head1 &lt;= tail1 &amp;&amp; q1[tail1] &gt; a[i]) tail1--; while (head2 &lt;= tail2 &amp;&amp; q2[tail2] &gt; b[i]) tail2--; if (tail1 != tail2) break; q1[++tail1] = a[i], q2[++tail2] = b[i]; pos = i; &#125; write(pos); pn; &#125; return 0;&#125; 上面的题解通过不断遍历比较笛卡尔树的最右路径来判断笛卡尔树的构造，经实测可行，或许下面这种解释更容易懂虽然我没看懂233333就这样吧…这文估计没有人能看明白，我真的好菜啊55555]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构,笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++大数板子]]></title>
    <url>%2F2019%2F07%2F18%2FC%2B%2B%E5%A4%A7%E6%95%B0%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[今天在训练的时候发现的很好用的C++大数板子，存一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define MAXN 9999#define MAXSIZE 1010#define DLEN 4class BigNum&#123;private: int x[5000], a[5000], y[5000], b[5000]; //可以控制大数的位数 int len;public: BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125; //构造函数 BigNum(const ll); //将一个int类型的变量转化成大数 BigNum(const char*); //将一个字符串类型的变量转化为大数 BigNum(const BigNum&amp;); //拷贝构造函数 BigNum&amp; operator=(const BigNum&amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符 friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符 BigNum operator+(const BigNum&amp;)const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum&amp;)const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum&amp;)const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int&amp;)const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int&amp;)const; //大数的n次方运算 int operator%(const int&amp;)const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum&amp; T)const; //大数和另一个大数的大小比较 bool operator&gt;(const int&amp; t)const; //大数和一个int类型的变量的大小比较 void print(); //输出大数&#125;;BigNum::BigNum(const ll b) //将一个int类型的变量转化为大数&#123; ll c, d = b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) &#123; c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;BigNum::BigNum(const char* s) //将一个字符串类型的变量转化为大数&#123; int t, k, index, L, i; memset(a, 0, sizeof(a)); L = strlen(s); len = L / DLEN; if (L % DLEN)len++; index = 0; for (i = L - 1; i &gt;= 0; i -= DLEN) &#123; t = 0; k = i - DLEN + 1; if (k &lt; 0)k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; &#125;&#125;BigNum::BigNum(const BigNum&amp; T) :len(T.len) //拷贝构造函数&#123; int i; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = T.a[i];&#125;BigNum&amp; BigNum::operator=(const BigNum&amp; n) //重载赋值运算符，大数之间赋值运算&#123; int i; len = n.len; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = n.a[i]; return *this;&#125;istream&amp; operator&gt;&gt;(istream&amp; in, BigNum&amp; b)&#123; char ch[MAXSIZE * 4]; int i = -1; in &gt;&gt; ch; int L = strlen(ch); int count = 0, sum = 0; for (i = L - 1; i &gt;= 0;) &#123; sum = 0; int t = 1; for (int j = 0; j &lt; 4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10) &#123; sum += (ch[i] - '0') * t; &#125; b.a[count] = sum; count++; &#125; b.len = count++; return in;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b) //重载输出运算符&#123; int i; cout &lt;&lt; b.a[b.len - 1]; for (i = b.len - 2; i &gt;= 0; i--) &#123; printf("%04d", b.a[i]); &#125; return out;&#125;BigNum BigNum::operator+(const BigNum&amp; T)const //两个大数之间的相加运算&#123; BigNum t(*this); int i, big; big = T.len &gt; len ? T.len : len; for (i = 0; i &lt; big; i++) &#123; t.a[i] += T.a[i]; if (t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -= MAXN + 1; &#125; &#125; if (t.a[big] != 0) t.len = big + 1; else t.len = big; return t;&#125;BigNum BigNum::operator-(const BigNum&amp; T)const //两个大数之间的相减运算&#123; int i, j, big; bool flag; BigNum t1, t2; if (*this &gt; T) &#123; t1 = *this; t2 = T; flag = 0; &#125; else &#123; t1 = T; t2 = *this; flag = 1; &#125; big = t1.len; for (i = 0; i &lt; big; i++) &#123; if (t1.a[i] &lt; t2.a[i]) &#123; j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while (t1.a[len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1;&#125;BigNum BigNum::operator*(const BigNum&amp; T)const //两个大数之间的相乘&#123; BigNum ret; int i, j, up; int temp, temp1; for (i = 0; i &lt; len; i++) &#123; up = 0; for (j = 0; j &lt; T.len; j++) &#123; temp = a[i] * T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if (up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1)ret.len--; return ret;&#125;BigNum BigNum::operator/(const int&amp; b)const //大数对一个整数进行相除运算&#123; BigNum ret; int i, down = 0; for (i = len - 1; i &gt;= 0; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; &#125; ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;int BigNum::operator%(const int&amp; b)const //大数对一个 int类型的变量进行取模&#123; int i, d = 0; for (i = len - 1; i &gt;= 0; i--) d = ((d * (MAXN + 1)) % b + a[i]) % b; return d;&#125;BigNum BigNum::operator^(const int&amp; n)const //大数的n次方运算&#123; BigNum t, ret(1); int i; if (n &lt; 0)exit(-1); if (n == 0)return 1; if (n == 1)return *this; int m = n; while (m &gt; 1) &#123; t = *this; for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1) t = t * t; m -= i; ret = ret * t; if (m == 1)ret = ret * (*this); &#125; return ret;&#125;bool BigNum::operator&gt;(const BigNum&amp; T)const //大数和另一个大数的大小比较&#123; int ln; if (len &gt; T.len)return true; else if (len == T.len) &#123; ln = len - 1; while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if (ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; &#125; else return false;&#125;bool BigNum::operator&gt;(const int&amp; t)const //大数和一个int类型的变量的大小比较&#123; BigNum b(t); return *this &gt; b;&#125;void BigNum::print() //输出大数&#123; int i; printf("%d", a[len - 1]); for (i = len - 2; i &gt;= 0; i--) printf("%04d", a[i]); printf("\n");&#125;ll Scan() &#123; int ch, flag = 0; ll res = 0; if ((ch = getchar()) == '-') flag = 1; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + ch - '0'; return flag ? -res : res;&#125;BigNum a, b, c, d, e, f;int main() &#123; ll X, A, Y, B; while (scanf("%lld%lld%lld%lld", &amp;X, &amp;A, &amp;Y, &amp;B) != EOF) &#123; a = BigNum(X); b = BigNum(A); c = BigNum(Y); d = BigNum(B); e = a * d, f = b * c; if (e &gt; f) printf("&gt;\n"); else if (f &gt; e) printf("&lt;\n"); else printf("=\n"); &#125; return 0;&#125; （上面的code也是下面这道签到题的题解，可以自行验证） Sample Input&amp;&amp;Output Sample Input:23 101 2 04 8 36 10 12 11 1 11 1 1 Sample Output:20]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>大数运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PTA] 练习4.2 平衡二叉树的根]]></title>
    <url>%2F2019%2F04%2F14%2F%5BPTA%5D%20%E7%BB%83%E4%B9%A04.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[一道AVL树的实现题，刚好借着这个机会复习一下AVL的概念和代码。 AVL树的概念链接我真的是越来越懒了 Problem Description 将给定的一系列数字插入初始为空的AVL树，请你输出最后生成的AVL树的根结点的值。 Input&amp;&amp;Output 输入的第一行给出一个正整数N（≤20），随后一行给出N个不同的整数，其间以空格分隔。 在一行中输出顺序插入上述整数到一棵初始为空的AVL树后，该树的根结点的值。 Sample Input&amp;&amp;Output1： 588 70 61 96 120 70 2： 788 70 61 96 120 90 65 88 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct node* AVLNode;struct node &#123; AVLNode Left, Right; int Data;&#125;;int GetHeight(AVLNode A) &#123; if (!A) return 0; else &#123; int L = GetHeight(A-&gt;Left); int R = GetHeight(A-&gt;Right); return max(L, R) + 1; &#125;&#125;AVLNode SingleLeftRotation(AVLNode A) &#123; AVLNode B = A-&gt;Left; A-&gt;Left = B-&gt;Right; B-&gt;Right = A; return B;&#125;AVLNode SingleRightRotation(AVLNode A) &#123; AVLNode B = A-&gt;Right; A-&gt;Right = B-&gt;Left; B-&gt;Left = A; return B;&#125;AVLNode DoubleLeftRightRotation(AVLNode A) &#123; A-&gt;Left = SingleRightRotation(A-&gt;Left); return SingleLeftRotation(A);&#125;AVLNode DoubleRightLeftRotation(AVLNode A) &#123; A-&gt;Right = SingleLeftRotation(A-&gt;Right); return SingleRightRotation(A);&#125;AVLNode Insert(AVLNode A, int x) &#123; if (!A) &#123; AVLNode A = new node(); A-&gt;Data = x; A-&gt;Left = A-&gt;Right = NULL; return A; &#125; else if (x &lt; A-&gt;Data) &#123; A-&gt;Left = Insert(A-&gt;Left, x); if (GetHeight(A-&gt;Left) - GetHeight(A-&gt;Right) == 2) &#123; if (x &lt; A-&gt;Left-&gt;Data) A = SingleLeftRotation(A); else A = DoubleLeftRightRotation(A); &#125; &#125; else if (x &gt; A-&gt;Data) &#123; A-&gt;Right = Insert(A-&gt;Right, x); if (GetHeight(A-&gt;Right) - GetHeight(A-&gt;Left) == 2) &#123; if (x &gt; A-&gt;Right-&gt;Data) A = SingleRightRotation(A); else A = DoubleRightLeftRotation(A); &#125; &#125; return A;&#125;int main() &#123; int n, x; AVLNode A = NULL; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;x); A = Insert(A, x); &#125; printf("%d", A-&gt;Data); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构,平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Windows换行符及gethar()替代]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%85%B3%E4%BA%8EWindows%E6%8D%A2%E8%A1%8C%E7%AC%A6%E4%BB%A5%E5%8F%8Agethar-%E6%9B%BF%E4%BB%A3%E7%9A%84%E8%AE%A8%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[昨天在做2050的时候居然在第一道签到题罚了六次时？？当时直接懵逼，把题目给小伙伴帮我重新写了一个(阿洋NB！)，之后看集训群里面才知道是换行符的锅(haoyuan学长NB！)。 查阅了一下：原链接 在Windows中, ‘\r’ 回车，回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖； ‘\n’ 换行，换到当前位置的下一行，而不会回到行首； Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\n”；Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”；Mac系统里，每行结尾是“&lt;回车&gt;”，即”\r”；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 Linux中遇到换行符(“\n”)会进行回车+换行的操作，回车符反而只会作为控制字符(“^M”)显示，不发生回车的操作。而windows中要回车符+换行符(“\r\n”)才会回车+换行，缺少一个控制符或者顺序不对都不能正确的另起一行。 而杭电的判题机是Windows的，所以妄图单独用一个getchar()读掉回车符的操作就gg了。 所以，尽快熟悉String的使用吧，getline()大法好啊！ 使用String完成循环读取字符串并挨个字符处理：123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; while (getline(cin, str)) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; // &#125; &#125; return 0;&#125; （等等…我在写这篇文章的时候突然意识到了学长的真正意思应该是使用getline()读掉换行…）]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2050] 冰水挑战（dp思路简单总结）]]></title>
    <url>%2F2019%2F04%2F14%2F2050-%E5%86%B0%E6%B0%B4%E6%8C%91%E6%88%98%EF%BC%88dp%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Problem Description Polar Bear Pitching helps you crystallize your message.The stage could not be any cooler, and we mean literally:a hole cut through the ice in the frozen Baltic Sea. 2050有一项很有挑战的活动 —— Polar Bear Pitching 。体验人跳入冰水中讲述自己的恐惧，改变以及梦想。这是没有时间限制的演讲，就看你能在冰水中呆多久！ 现在，我们要依次面对 n 个冰水挑战，每个挑战你都可以选择接受或不接受。接受第 i 个挑战会让你丧失 ai点体力，因为每个挑战所处的环境不同，如果你要挑战它，在挑战它之前你的体力 x 会变&gt;成 min(x,bi)，当你完成这个挑战的时候，你的体力会变成 x−ai，体力任何时候不允许小于等于 0，无论你是否接受第 i 个挑战，在这个挑战结束以后你的体力都会增加 ci。 现在我们想知道最多可以完成多少个挑战。 Input&amp;&amp;Output 第一行一个正整数 T (T≤50) 表示数据组数。接下来 T 组数据，每组第一行两个正整数 n,c (1≤n≤103,1≤c≤109)，表示挑战的数量和初始体力，接下来 n 行，每行三个非负整数 ai,bi,ci(0≤ai,bi,ci≤109)。 对于每组数据输出一行一个数，表示你最多能完成几个挑战。 Sample Input&amp;&amp;Output Sample Input:23 101 2 04 8 36 10 12 11 1 11 1 1 Sample Output:20 问题分析很典型的dp题，所以也想借这个题好好理一理面临dp时候的思路。 首先，啥是dp？在递归的时候，我们可以通过不断地分解问题，将复杂的任务简化为最基本的小问题，比如基于递归实现的归并排序，排列，组合等。不过有时候，我们并不用处理所有可能的情况，只要找到满足条件的最优解就可以了，这种情况下，我们需要在各种可能的局部解中，找出那些可能达到最优的局部解，而放弃其他的局部解，这个寻找最优解的过程叫动态规划。（这段话我是从这里摘的）所以，dp就是一个不断寻找局部最优解并更新的过程。 下一个问题，什么样的题可以用动态规划来解决？首先，如果一个问题有多种可能，看上去需要排列或者组合的思想，但是最终求的只是最优解，如最大值，最小值，最短子串，最长子串等，可以试试使用动态规划。其实，状态转移方程是个关键。你可以用状态转移表来帮助自己理解整个过程。如果能找到准确的转移方程，那么离最终的代码实现也就不远了 。这里说下什么是状态转移方程：从上一个状态到下一个状态之间可能存在一些变化，以及基于这些变化的最终决策结果。我们把这样的表达式称为状态转移方程。所有的动态规划算法中，状态转移是关键。（我还是从上面的链接摘的，我好懒） 由此我们知道，需要不断寻找局部最优解，并且能写出状态转移方程的题目，就直接写dp跑就行了（大概）。 接下来我们回到这个题目，dp的思路已经十分明确了： 建立一个数组是s[0~n]来存储接受0~n个挑战后的体力（最优体力） 尝试建立状态转移方程：s[j + 1] = max(s[j + 1], min(s[j], b[i]) - a[i] + c[i]);（abc数组的具体含义去阅读我的完整代码好不啦）。注意：因为每次是s[j]更新都需要要用到是s[j-1]的值，因此在同一个挑战里面更新s[j]需要逆序循环。（我仿佛突然明白了运筹学课本里说dp一般逆序的含义？？运筹学NB！！） 从头开始跑一遍所有挑战，并建立变量m存储最多的挑战次数 Over~今天的小宸依旧是又进步了一点点的小菜鸡呢 完整代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int t, n;int main() &#123; scanf("%d", &amp;t); while (t--) &#123; int a[1010], b[1010], c[1010], s[1010] = &#123; 0 &#125;; scanf("%d %d", &amp;n, &amp;s[0]); for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d %d", &amp;a[i], &amp;b[i], &amp;c[i]); &#125; int m = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = m; j &gt;= 0; j--) &#123; if (min(s[j], b[i]) - a[i] &gt; 0) &#123; s[j + 1] = max(s[j + 1], min(s[j], b[i]) - a[i] + c[i]); s[j] += c[i]; m = max(m, j + 1); &#125; else &#123; s[j] += c[i]; &#125; &#125; &#125; printf("%d\n", m); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔的非递归实现]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%B1%89%E8%AF%BA%E5%A1%94%2F</url>
    <content type="text"><![CDATA[题目与分析今天在刷pta上面的数据结构的时候，发现居然忘了汉诺塔怎么做…日…我真的是越来越菜了…汉诺塔是什么这里就不用来重复了吧？附个链接，有兴趣的自己去看。 接下来简单的讲一下思路。我们都知道汉诺塔的思想就是靠和尚们互相推诿来做对吧？当你是其中一个和尚，你看见一堆盘子丢在a柱上面，你要做的事情只有三个： 命令小和尚把除了最后一个之外的盘子全都丢在b柱上。 自己把a柱上最后一个盘子放在c柱上。 命令小和尚把b柱上的盘子丢在c柱上，自己走人。 这样一看多简单啊！多么醉人的递归思想 来，直接po代码了。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct node &#123; int n; char a, b, c; node(int m, int x, int y, int z) :n(m), a(x), b(y), c(z)&#123;&#125;&#125;node;stack &lt;node&gt; s;int main() &#123; int n; scanf("%d", &amp;n); s.push(node(n, 'a', 'b', 'c')); while (!s.empty()) &#123; node t = s.top(); s.pop(); if (t.n == 1) printf("%c -&gt; %c\n", t.a, t.c); else &#123; s.push(node(t.n - 1, t.b, t.a, t.c)); s.push(node(1, t.a, t.b, t.c)); s.push(node(t.n - 1, t.a, t.c, t.b)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["Hello World！"]]></title>
    <url>%2F2019%2F03%2F30%2FHello%20World!%2F</url>
    <content type="text"><![CDATA[小宸写的第一篇博文好叭！话说，这里真的是正文嘛？？哇靠，写起来这么奇怪的吗？写在这里真的会显示在网页上嘛？我好怀疑啊（盯 还有，hexo的原生主题也太丑了吧….看不下去的那种好吗？？？ 时间有限，我就先写这么多了哟！有时间再来好好研究下这玩意！ 下面是我的试验田 1printf("这里应该是代码块"); 这是一级标题这是二级标题]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
